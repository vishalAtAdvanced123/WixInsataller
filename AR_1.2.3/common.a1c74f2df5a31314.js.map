{"version":3,"file":"common.a1c74f2df5a31314.js","mappings":"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","names":["PageHeaderComponent","constructor","ngOnInit","selectors","i0","message","required","telephoneConsists","validDate","validNumber","numberRange","numberRange2","validEmail","inUse","unique","specialCharacter","fillForm","limit50","limit200","limit1000","minInput","maxInput","saveError","deleteError","validHours","validTime","notZero","futureDate","dataChanged","datePickerPlaceholder","localeDateFormatMM","invalidDateFormat","negativeDate","negativeTime","uniqueSelect","negativeNumber","absenceOverlap","noAbsencesForDate","absenceInPast","absenceDeadline","absenceInPastEdit","absenceEmployeeDeleteMessage","absenceDeletePending","scheduleUnlockWarning","scheduleLockWarning","subGroupUnlockWarning","subGroupLockWarning","lockedPeriodWarning","dateRangeNavigationWarning","jobOutOfRangeWarning","jobRangeOverlapsLockedRange","jobOutOfScheduleRangeWarning","publishTemplate","templateSubgroupWarning","templateJobCreateOnDrag","templateJobWarning","systemPreferencesChanged","customDataLookupInUse","decimalInputMessage","offerJobs","revokeJobOffers","loneWorkerReccuringIntervalsGreaterThanResponseWindow","loneWorkerReccuringIntervalsValidValue","loneWorkerResponseWindowValidValue","maxLength","minWeeklyHours","maxWeeklyHours","employeeProfileWarning","userProfileWarning","confirmPrompt","action","deletePrompt","name","activeDeleteError","leavePagePrompt","deadlineMessage","deadline","unassignedCriticalTasks","CheckDates","controlName","matchingControlName","formGroup","control","controls","matchingControl","errors","invalidDate","value","Date","setErrors","CheckDatesDiff","startDate","setHours","endDate","CheckPasswords","newPassword","toString","confirmNewPassword","passwordMismatch","CompareWithOldPassword","oldPassword","minlength","passwordContainsMinimumCharacters","sameAsOldPassword","CheckIfPasswordContainsMinimum","minimumUpperCharacters","minimumSpecialCharacters","minimumNumericCharacters","minimumPasswordLength","length","upperCounter","specialCounter","numericCounter","character","i","charAt","toUpperCase","toLowerCase","emitEvent","setValidators","Validators","updateValueAndValidity","CompareTime","invalidTime","startTime","moment","isBefore","CompareMultipleTimeInputs","controlNameOne","controlNameTwo","controlNameThree","controlOne","controlTwo","controlThree","invalidTimeRelation","CheckDropdown","notificationTypeID","noSelection","trimWhiteSpaceValidator","value2","String","trim","setValidationOnCheckboxChange","checkboxControlNameParam","firstTimeInputControlNameParam","secondTimeInputControlNameParam","setValueOptions","markOptions","onlySelf","updateOptions","firstTimeInputControlName","secondTimeInputControlName","markAsUntouched","compareAttendanceTimeRelations","invalidResponseTime","timeBeforeStartMilliseconds","clone","valueOf","responseWindowMilliseconds"],"sourceRoot":"webpack:///","sources":["./src/app/shared/modules/page-header/page-header.component.ts","./src/app/shared/modules/page-header/page-header.component.html","./src/app/shared/utils/user-messages.ts","./src/app/shared/validators/customValidators.ts"],"sourcesContent":["import { Component, OnInit, Input } from '@angular/core';\r\nimport { RouterModule } from '@angular/router';\r\n\r\n@Component({\r\n    selector: 'app-page-header',\r\n    templateUrl: './page-header.component.html',\r\n    styleUrls: ['./page-header.component.scss']\r\n})\r\nexport class PageHeaderComponent implements OnInit {\r\n    @Input() heading: string;\r\n    @Input() icon: string;\r\n    constructor() {\r\n        //\r\n    }\r\n\r\n    ngOnInit() {\r\n        //\r\n    }\r\n}\r\n","<div class=\"row\">\r\n    <div class=\"col-xl-12\">\r\n        <h2 class=\"page-header\">\r\n            {{heading}}\r\n        </h2>\r\n        <ol class=\"breadcrumb\">\r\n            <li class=\"breadcrumb-item\">\r\n                <i class=\"fa fa-dashboard\"></i> <a href=\"Javascript:void(0)\" [routerLink]=\"['/dashboard']\">Dashboard</a>\r\n            </li>\r\n            <li class=\"breadcrumb-item active\"><i class=\"fa {{icon}}\"></i> {{heading}}</li>\r\n        </ol>\r\n    </div>\r\n</div>\r\n","import { HttpErrorResponse } from '@angular/common/http';\r\nimport { localeDateFormatMM } from 'src/app/app.module';\r\n\r\n\r\nexport const message = {\r\n    //Form validation messages\r\n    required: \" is required.\",\r\n    telephoneConsists: \" must consist of numbers and ()+-/ symbols.\",\r\n    validDate: \" must be a valid date.\",\r\n    validNumber: \"Must be a valid number.\",\r\n    numberRange: \"Must be a whole number between \",\r\n    numberRange2: \"Must be number between \",\r\n    validEmail: \" must be a valid email.\",\r\n    inUse: \" is already in use.\",\r\n    unique: \" must be unique.\",\r\n    specialCharacter: \" cannot include only special characters.\",\r\n    fillForm: \"Please fill in the form correctly.\",\r\n    limit50: \"Maximum input is 50 characters.\",\r\n    limit200: \"Maximum input is 200 characters.\",\r\n    limit1000: \"Maximum input is 1000 characters.\",\r\n    minInput: \"Minimum input is \",\r\n    maxInput: \"Maximum input is \",\r\n    saveError: \"Error saving \",\r\n    deleteError: \"Error deleting \",\r\n    validHours: \"Must be in valid HH:MM format.\",\r\n    validTime: \"Maximum value is 24:00 hours.\",\r\n    notZero: \"Time must be greater than 00:00.\",\r\n    futureDate: \" can not be in the future.\",\r\n    dataChanged: \"This action can not be performed. The data has been changed by another user.\",\r\n    datePickerPlaceholder: localeDateFormatMM,\r\n    invalidDateFormat: \"Unrecognised date. Please input date in the format: \" + localeDateFormatMM,\r\n    negativeDate: \"End Date cannot be before Start Date\",\r\n    negativeTime: \" cannot be before \",\r\n    uniqueSelect: \" must not be the same as \",\r\n    negativeNumber: \"Leave date must be after start date.\",\r\n    absenceOverlap: \"Absences cannot overlap\",\r\n    noAbsencesForDate: \"No absence record exists for the selected date\",\r\n    absenceInPast: \"Cannot request absences in past\",\r\n    absenceDeadline: \"Cannot request absences before deadline of \",\r\n    absenceInPastEdit: \"Cannot edit absences in past\",\r\n    absenceEmployeeDeleteMessage: \"Delete request submitted\",\r\n    absenceDeletePending: \"Delete request has already been submitted\",\r\n    scheduleUnlockWarning: \"You are about to make changes to the approved schedule. In order to update the employees about the changes, you need to submit the updated schedule for approval.\",\r\n    scheduleLockWarning: \"Any affected employees will now be notified of these changes.\",\r\n    subGroupUnlockWarning: \"You are about to make changes to the approved schedule. In order to update the employees about the changes, you need to submit the updated schedule for approval.\",\r\n    subGroupLockWarning: \"Any affected employees will now be notified of these changes.\",\r\n    lockedPeriodWarning: \"This period is locked.\",\r\n    dateRangeNavigationWarning: \"You cannot navigate outside of the viewed date range.\",\r\n    jobOutOfRangeWarning: \" cannot land in locked date range.\",\r\n    jobRangeOverlapsLockedRange: \"Job date range cannot overlap locked date range.\",\r\n    jobOutOfScheduleRangeWarning: \"Cannot create job outside the selected schedule date range.\",\r\n    publishTemplate: \"Schedules using this template will updated to the new template.\",\r\n    templateSubgroupWarning: \"Job cannot be created outside of the subgroup date range.\",\r\n    templateJobCreateOnDrag: \"Maximum job duration is two days.\",\r\n    templateJobWarning: \" is outside of the subgroup date range.\",\r\n    systemPreferencesChanged: \"In the meantime, changes have been made in security settings. Try again.\",\r\n    customDataLookupInUse: \"This lookup is currently in use so it cannot be deleted.\",\r\n    decimalInputMessage: \"Please enter whole or decimal positive number.\",\r\n    offerJobs: \"Offer all open job slots to available employees.\",\r\n    revokeJobOffers: \"Revoke all job offers not already excepted.\",\r\n    loneWorkerReccuringIntervalsGreaterThanResponseWindow: \"Reccuring intervals should be 3 times greater than response window.\",\r\n    loneWorkerReccuringIntervalsValidValue: \"Reccuring intervals should be between 00:01 and 23:59.\",\r\n    loneWorkerResponseWindowValidValue: \"Response window should be between 00:01 and 23:59.\",\r\n    maxLength: \"Cannot enter more than \",\r\n    minWeeklyHours: \"Minimum value for weekly hours is 0\",\r\n    maxWeeklyHours: \"Maximum value for weekly hours is 158\",\r\n    employeeProfileWarning: \"Assigning a selected Employee Profile will override the existing Employee profile that any Employee may have assigned already. Click 'Save Changes' in order to continue.\",\r\n    userProfileWarning: \"Assigning a selected User Profile will override the existing User profile that any User may have assigned already. Click 'Save Changes' in order to continue.\"\r\n};\r\n\r\nexport function confirmPrompt(action: string): string {\r\n    return \"Are you sure you wish to \" + action + \"? Click Cancel if you do not wish to proceed with this operation. Note: Only current and future jobs will be submitted for approval.\"\r\n}\r\n\r\nexport function deletePrompt(name: string): string {\r\n    return \"Deletion of a\" + name + \"(s) cannot be undone. Click Cancel if you do not wish to proceed with operation.\"\r\n}\r\n\r\nexport function activeDeleteError(name: string): string {\r\n    return name + \" cannot be deleted when in use.\"\r\n}\r\n\r\nexport function leavePagePrompt(): string {\r\n    return \"Confirm leaving this page. Unsaved changes will be discarded.\"\r\n}\r\n\r\nexport function scheduleLeavePagePrompt(): string {\r\n    return \"Confirm leaving this page. Leaving the page while the schedule is unlocked will result in losing potential changes.\"\r\n}\r\n\r\nexport function deadlineMessage(deadline: any): string {\r\n    return \"You are attempting to book an absence for a date range which is in breach of the minimum notice period (\"\r\n    + deadline +\r\n    \" day/s). Please try a different date range.\"\r\n}\r\n\r\nexport function unassignedCriticalTasks(name: string): string {\r\n    return \"There are critical task jobs in \" + name + \" that do not have the required employees assigned\"\r\n}","import { FormGroup, ValidatorFn, Validators } from '@angular/forms';\r\nimport * as moment from \"moment\";\r\n\r\n// custom validator to check time of two dates\r\nexport function CheckDates(controlName: string, matchingControlName: string) {\r\n    return (formGroup: FormGroup) => {\r\n        const control = formGroup.controls[controlName];\r\n        const matchingControl = formGroup.controls[matchingControlName];\r\n\r\n        if (matchingControl.errors && !matchingControl.errors.invalidDate) {\r\n            // return if another validator has already found an error on the matchingControl\r\n            return;\r\n        }\r\n\r\n        // set error on matchingControl if validation fails\r\n        if (control.value &&  matchingControl.value) {\r\n            if ((new Date(control.value) > new Date(matchingControl.value)) && (matchingControl.value != null)) {\r\n                matchingControl.setErrors({ invalidDate: true });\r\n            } else {\r\n                matchingControl.setErrors(null);\r\n            }\r\n        } else {\r\n            matchingControl.setErrors(null);\r\n        }\r\n    }\r\n}\r\n\r\n// custom validator to check if difference in two dates in negative days\r\nexport function CheckDatesDiff(controlName: string, matchingControlName: string) {\r\n    return (formGroup: FormGroup) => {\r\n        const control = formGroup.controls[controlName];\r\n        const matchingControl = formGroup.controls[matchingControlName];\r\n\r\n        if (matchingControl.errors && !matchingControl.errors.invalidDate) {\r\n            // return if another validator has already found an error on the matchingControl\r\n            return;\r\n        }\r\n        // set error on matchingControl if validation fails\r\n        const startDate = new Date(control.value).setHours(0,0,0,0);\r\n        const endDate = new Date(matchingControl.value).setHours(0,0,0,0);\r\n        if ((startDate > endDate) && (matchingControl.value != null)) {\r\n            matchingControl.setErrors({ negativeDate: true });\r\n        } else {\r\n            matchingControl.setErrors(null);\r\n        }\r\n    }\r\n}\r\n\r\n// custom validator to compare two passwords\r\nexport function CheckPasswords(controlName: string, matchingControlName: string) {\r\n    return (formGroup: FormGroup) => {\r\n        const newPassword = formGroup.controls[controlName.toString()];\r\n        const confirmNewPassword = formGroup.controls[matchingControlName.toString()];\r\n\r\n        if(newPassword.value && confirmNewPassword.value) {\r\n            if (confirmNewPassword.errors && confirmNewPassword.errors.required) {\r\n                return;\r\n            }\r\n    \r\n            // set error on matchingControl if validation fails\r\n            if (newPassword.value !== confirmNewPassword.value) {\r\n                confirmNewPassword.setErrors({ passwordMismatch: true });\r\n            } else {\r\n                confirmNewPassword.setErrors(null);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// custom validator to check if new password is the same as old one\r\nexport function CompareWithOldPassword(controlName: string, matchingControlName: string) {\r\n    return (formGroup: FormGroup) => {\r\n        const oldPassword = formGroup.controls[controlName.toString()];\r\n        const newPassword = formGroup.controls[matchingControlName.toString()];\r\n\r\n        if(oldPassword.value && newPassword.value) {\r\n            if (newPassword.errors\r\n                && (newPassword.errors.required || newPassword.errors.minlength || newPassword.errors.passwordContainsMinimumCharacters)) {\r\n                // return if another validator has already found an error on the matchingControl\r\n                return;\r\n            }\r\n            // set error on matchingControl if validation fails\r\n            if (oldPassword.value === newPassword.value) {\r\n                newPassword.setErrors({ sameAsOldPassword: true });\r\n            } else {\r\n                newPassword.setErrors(null);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport function CheckIfPasswordContainsMinimum(formGroup: FormGroup, controlName: string, minimumUpperCharacters: number, minimumSpecialCharacters: number, minimumNumericCharacters: number, minimumPasswordLength: number){\r\n    const newPassword = formGroup.controls[controlName];\r\n    if (minimumUpperCharacters < 1 && minimumSpecialCharacters < 1 && minimumNumericCharacters < 1) {\r\n        return;\r\n    }\r\n    if (newPassword.errors\r\n        && (newPassword.errors.required || newPassword.errors.minlength || newPassword.errors.sameAsOldPassword || newPassword.errors.passwordMismatch)) {\r\n        // return if another validator has already found an error on the passwordContainsMinimumCharacters\r\n        return;\r\n    }\r\n\r\n    if(newPassword.value.length < minimumPasswordLength){\r\n        newPassword.setErrors({ minlength: true });\r\n        return;\r\n   }\r\n\r\n    let upperCounter = 0;\r\n    let specialCounter = 0;\r\n    let numericCounter = 0;\r\n    let character='';\r\n    for(let i = 0; i < newPassword.value.length; i++){\r\n        character = newPassword.value.charAt(i);\r\n        if(character >= '0' && character <= '9'){\r\n            //it is a numeric\r\n            numericCounter++;\r\n        }\r\n        else if(character.toUpperCase() != character.toLowerCase()){\r\n            //it is a letter\r\n            //check is upper\r\n            if(character == character.toUpperCase()){\r\n                upperCounter++;\r\n            }\r\n        }\r\n        else{\r\n            //it is a special character\r\n            specialCounter++;\r\n        }\r\n    }\r\n    if(upperCounter >= minimumUpperCharacters && specialCounter >= minimumSpecialCharacters && numericCounter >= minimumNumericCharacters){\r\n        newPassword.setErrors(null,{ emitEvent: false });\r\n        newPassword.setValidators(Validators.maxLength(50));\r\n        newPassword.updateValueAndValidity();\r\n    }\r\n    else{\r\n        newPassword.setErrors({ passwordContainsMinimumCharacters: true });\r\n    }\r\n}\r\n\r\n// custom validator to compare relation of two time entries\r\nexport function CompareTime(controlName: string, matchingControlName: string) {\r\n    return (formGroup: FormGroup) => {\r\n        const control = formGroup.controls[controlName];\r\n        const matchingControl = formGroup.controls[matchingControlName];\r\n        \r\n        if (matchingControl.errors && !matchingControl.errors.invalidTime) {\r\n            // return if another validator has already found an error on the matchingControl\r\n            return;\r\n        }\r\n        \r\n        // set error on matchingControl if validation fails\r\n        const startTime = moment(control.value, 'HH:mm');\r\n        const endTime = moment(matchingControl.value, 'HH:mm');\r\n        if ((endTime.isBefore(startTime)) && (matchingControl.value != null)) {\r\n            matchingControl.setErrors({ invalidTime: true });\r\n        } else {\r\n            matchingControl.setErrors(null);\r\n        }\r\n    }\r\n}\r\n\r\n// custom validator to compare relation of two out of three time entries (used in job filter for Schedule)\r\nexport function CompareMultipleTimeInputs(controlNameOne: string, controlNameTwo: string, controlNameThree: string) {\r\n    return (formGroup: FormGroup) => {\r\n        const controlOne = formGroup.controls[controlNameOne];\r\n        const controlTwo = formGroup.controls[controlNameTwo];\r\n        const controlThree = formGroup.controls[controlNameThree];\r\n\r\n        if(\r\n            controlThree.value == \"\" ||\r\n            controlOne.value == \"\"\r\n        ) {\r\n            return;\r\n        }\r\n        \r\n        if (controlThree.errors && !controlThree.errors.invalidTimeRelation) {\r\n            // return if another validator has already found an error on the controlThree\r\n            return;\r\n        }\r\n        \r\n        // set error on controlThree if validation fails\r\n        const startTime = moment((controlTwo.value && controlTwo.value !== \"\" ? controlTwo.value : controlOne.value), 'HH:mm');\r\n        const endTime = moment(controlThree.value, 'HH:mm');\r\n        if ((endTime.isBefore(startTime)) && (controlThree.value != null)) {\r\n            controlThree.setErrors({ invalidTimeRelation: true });\r\n        } else {\r\n            controlThree.setErrors(null);\r\n        }\r\n    }\r\n}\r\n\r\n// custom validator to check if selection is null\r\nexport function CheckDropdown(notificationTypeID: any) {\r\n    return (formGroup: FormGroup) => {\r\n        const control = formGroup.controls[notificationTypeID];\r\n\r\n        // set error on notificationID if validation fails\r\n        if (control.value == null) {\r\n            control.setErrors({ noSelection: true });\r\n        } else {\r\n            control.setErrors(null);\r\n        }\r\n    }\r\n}\r\n\r\nexport function trimWhiteSpaceValidator(value2: string): ValidatorFn {\r\n    const validator: ValidatorFn = (control) => {\r\n        const value = String(value2);\r\n        if (value) {\r\n            return value.trim() ? null : { required: true }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    return validator;\r\n}\r\n\r\n/**\r\n * Custom validator to set validations on two time inputs depending on checkbox state\r\n * used in Edit Job Type and Edit Job components forms\r\n */\r\nexport function setValidationOnCheckboxChange(\r\n    checkboxControlNameParam: string,\r\n    firstTimeInputControlNameParam: string,\r\n    secondTimeInputControlNameParam: string\r\n) {\r\n    return (formGroup: FormGroup) => {\r\n        const setValueOptions = { emitEvent: false };\r\n        const markOptions = { onlySelf: true };\r\n        const updateOptions = { onlySelf: true, emitEvent: false };\r\n        const checkboxControlName = formGroup.controls[checkboxControlNameParam];\r\n        const firstTimeInputControlName = formGroup.controls[firstTimeInputControlNameParam];\r\n        const secondTimeInputControlName = formGroup.controls[secondTimeInputControlNameParam];\r\n        if(checkboxControlName.value) {\r\n            firstTimeInputControlName.setValidators([Validators.required, Validators.minLength(5)]);\r\n            secondTimeInputControlName.setValidators([Validators.required, Validators.minLength(5)]);\r\n        } else {\r\n            firstTimeInputControlName.markAsUntouched(markOptions);\r\n            firstTimeInputControlName.setErrors(null, setValueOptions);\r\n            firstTimeInputControlName.setValidators([]);\r\n            secondTimeInputControlName.markAsUntouched(markOptions);\r\n            secondTimeInputControlName.setErrors(null, setValueOptions);  \r\n            secondTimeInputControlName.setValidators([]);\r\n        }\r\n        firstTimeInputControlName.updateValueAndValidity(updateOptions);\r\n        secondTimeInputControlName.updateValueAndValidity(updateOptions);\r\n    }\r\n}\r\n\r\n/** Compares Attendance confirmation's attendanceTimeBeforeStart and attendanceResponseWindow values */\r\nexport function compareAttendanceTimeRelations(controlName: string, matchingControlName: string) {\r\n    return (formGroup: FormGroup) => {\r\n        const control = formGroup.controls[controlName];\r\n        const matchingControl = formGroup.controls[matchingControlName];\r\n        \r\n        if (matchingControl.errors && !matchingControl.errors.invalidResponseTime) {\r\n            // return if another validator has already found an error on the matchingControl\r\n            return;\r\n        }\r\n        \r\n        // set error on matchingControl if validation fails\r\n        const timeBeforeStartMilliseconds = moment(control.value, 'HH:mm').clone().valueOf();\r\n        const responseWindowMilliseconds = moment(matchingControl.value, 'HH:mm').clone().valueOf();\r\n        if ((timeBeforeStartMilliseconds < responseWindowMilliseconds) && (matchingControl.value != null)) {\r\n            matchingControl.setErrors({ invalidResponseTime: true });\r\n        } else {\r\n            matchingControl.setErrors(null);\r\n        }\r\n    }\r\n}\r\n\r\n// custom validator to compare two email addresses\r\nexport function CompareEmailAddresses(controlName: string, matchingControlName: string) {\r\n    return (formGroup: FormGroup) => {\r\n        const enterEmailAddress = formGroup.controls[controlName.toString()];\r\n        const confirmEmailAddress = formGroup.controls[matchingControlName.toString()];\r\n        if(enterEmailAddress.value && confirmEmailAddress.value) {\r\n            if (confirmEmailAddress.errors && confirmEmailAddress.errors.required) {\r\n                return;\r\n            }\r\n    \r\n            // set error on matchingControl if validation fails\r\n            if (enterEmailAddress.value !== confirmEmailAddress.value) {\r\n                confirmEmailAddress.setErrors({ emailAddressMismatch: true });\r\n            } else {\r\n                confirmEmailAddress.setErrors(null);\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"x_google_ignoreList":[]}